// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

// In Solidity, ABI encode has four functions: abi.encode, abi.encodePacked, abi.encodeWithSignature, abi.encodeWithSelector. While ABI decode has one function: abi.decode, which is used to decode the data of abi.encode.
contract ABI {
    uint x = 10;
    address addr = 0x7A58c0Be72BE218B41C608b7Fe7C5bB630736C71;
    string name = "0xAA";
    uint[2] array = [5, 6];

    //     abi.encode
    // Use ABI rules to encode the given parameters. ABI is designed to interact with smart contract by filling each parameter with 32 bytes data and splicing them together. If you want to interact with contracts, you should use abi.encode.

    function encode() public view returns (bytes memory result) {
        result = abi.encode(x, addr, name, array);
    }

    //   abi.encodePacked
    // Encode given parameters according to their minimum required space. It is similar to abi.encode, but omits a lot of 0 filled in. For example, only 1 byte is used to encode the uint type. You can use abi.encodePacked when you want to save space and don't interact with contracts. For example when computing hash of some data.

    function encodePacked() public view returns (bytes memory result) {
        result = abi.encodePacked(x, addr, name, array);
    }

    //     abi.encodeWithSignature
    // Similar with abi.encode function, but the first parameter is function signatures, such as "foo(uint256, address, string, uint256[2])". It can be used when calling other contracts.

    function encodeWithSignature() public view returns (bytes memory result) {
        result = abi.encodeWithSignature(
            "foo(uint256,address,string,uint256[2])",
            x,
            addr,
            name,
            array
        );
    }

    //     abi.encodeWithSelector
    // Similar to abi.encodeWithSignature, except that first argument is a function selector which is the first 4 bytes of function signature Keccak hash.

    function encodeWithSelector() public view returns (bytes memory result) {
        result = abi.encodeWithSelector(
            bytes4(keccak256("foo(uint256,address,string,uint256[2])")),
            x,
            addr,
            name,
            array
        );
    }

    //     abi.decode
    // abi.decode is used to decode the binary code generated by abi.encode and restore it to its original parameters.

    function decode(
        bytes memory data
    )
        public
        pure
        returns (
            uint dx,
            address daddr,
            string memory dname,
            uint[2] memory darray
        )
    {
        (dx, daddr, dname, darray) = abi.decode(
            data,
            (uint, address, string, uint[2])
        );
    }
}
